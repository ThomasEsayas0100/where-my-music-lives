<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Where Your Music Lives</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500&display=swap');

  *, *::before, *::after {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  :root {
    --fg: #c8c8c8;
    --fg-dim: #585858;
    --fg-bright: #e8e8e8;
    --bg: #0a0a0a;
    --scanline: rgba(255,255,255,0.015);
  }

  html, body {
    height: 100%;
    overflow: hidden;
    background: var(--bg);
    color: var(--fg);
    font-family: 'IBM Plex Mono', 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  }

  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  /* CRT scanline overlay */
  body::after {
    content: '';
    position: fixed;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      var(--scanline) 2px,
      var(--scanline) 4px
    );
    pointer-events: none;
    z-index: 100;
  }

  /* Subtle vignette */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: radial-gradient(
      ellipse at center,
      transparent 50%,
      rgba(0,0,0,0.6) 100%
    );
    pointer-events: none;
    z-index: 99;
  }

  .container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0;
    user-select: none;
    opacity: 0;
    transform: scale(0.97);
  }

  .title {
    font-size: 14px;
    font-weight: 300;
    letter-spacing: 0.45em;
    text-transform: uppercase;
    color: var(--fg-dim);
    margin-bottom: 24px;
    text-align: center;
  }

  .title span {
    display: inline-block;
  }

  #globe {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 13px;
    line-height: 1.05;
    color: var(--fg);
    white-space: pre;
    letter-spacing: 0.05em;
    text-align: center;
    text-shadow: 0 0 8px rgba(200,200,200,0.04);
    cursor: grab;
  }

  #globe.dragging {
    cursor: grabbing;
  }

  .status-area {
    margin-top: 28px;
    padding-top: 20px;
    border-top: 1px solid rgba(255,255,255,0.04);
    text-align: center;
    height: 56px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }

  .status-text {
    font-size: 12px;
    font-weight: 400;
    letter-spacing: 0.15em;
    color: var(--fg-dim);
    transition: opacity 0.4s ease;
    min-height: 1.2em;
  }

  .status-text.fading {
    opacity: 0;
  }

  .dots {
    display: flex;
    gap: 6px;
    align-items: center;
  }

  .dot {
    width: 3px;
    height: 3px;
    background: var(--fg-dim);
    border-radius: 50%;
    animation: pulse 1.8s ease-in-out infinite;
  }

  .dot:nth-child(2) { animation-delay: 0.2s; }
  .dot:nth-child(3) { animation-delay: 0.4s; }
  .dot:nth-child(4) { animation-delay: 0.6s; }
  .dot:nth-child(5) { animation-delay: 0.8s; }

  @keyframes pulse {
    0%, 80%, 100% { opacity: 0.2; transform: scale(1); }
    40% { opacity: 1; transform: scale(1.5); }
  }

  /* Responsive */
  @media (max-width: 600px) {
    #globe {
      font-size: 7px;
      line-height: 1;
    }
    .title {
      font-size: 11px;
      letter-spacing: 0.3em;
    }
  }

  @media (min-width: 601px) and (max-width: 1000px) {
    #globe {
      font-size: 10px;
      line-height: 1;
    }
  }
</style>
</head>
<body>

<div class="container" id="container">
  <div class="title">where&ensp;your&ensp;music&ensp;lives</div>
  <pre id="globe"></pre>
  <div class="status-area">
    <div class="dots">
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot"></div>
    </div>
    <div class="status-text" id="status">Fetching scrobbles</div>
  </div>
</div>

<script>
// ── Equirectangular world map (360×180, Natural Earth 110m) ───────
const MAP_IMG_SRC = 'data:image/png;base64,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';

const MAP_W = 360;
const MAP_H = 180;
let landData = null;

function loadWorldMap() {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = MAP_W;
      canvas.height = MAP_H;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, MAP_W, MAP_H);
      const pixels = ctx.getImageData(0, 0, MAP_W, MAP_H).data;

      landData = new Uint8Array(MAP_W * MAP_H);
      for (let i = 0; i < MAP_W * MAP_H; i++) {
        landData[i] = pixels[i * 4] > 128 ? 1 : 0;
      }
      resolve();
    };
    img.src = MAP_IMG_SRC;
  });
}

function isLandCached(lat, lon) {
  if (!landData) return false;
  lon = ((lon % 360) + 540) % 360 - 180;

  const px = Math.floor((lon + 180) / 360 * MAP_W);
  const py = Math.floor((90 - lat) / 180 * MAP_H);
  const x = Math.max(0, Math.min(MAP_W - 1, px));
  const y = Math.max(0, Math.min(MAP_H - 1, py));

  return landData[y * MAP_W + x] === 1;
}

// ── Fixed quality 6 shading ramp ──────────────────────────────────
const SHADE = ' .\u00b7:-=+*#%@';

// ── Globe renderer ─────────────────────────────────────────────────
// Light direction (normalized) — from upper-right-front
const lx = 0.35, ly = -0.55, lz = 0.75;
const lMag = Math.sqrt(lx*lx + ly*ly + lz*lz);
const LIGHT = [lx/lMag, ly/lMag, lz/lMag];
const CHAR_ASPECT = 0.57;
const DEG = 180 / Math.PI;
const GLOBE_H = 44;                                   // quality 6: 20 + 6*4
const GLOBE_W = Math.round(GLOBE_H / CHAR_ASPECT);    // ~77 cols

const maxSI = SHADE.length - 1;
const landBase = Math.max(1, Math.floor(maxSI * 0.5));
const landRange = maxSI - landBase;
const oceanRange = Math.max(1, landBase - 1);

function renderGlobe(rotation) {
  const radius = GLOBE_H / 2.1;
  const cx = GLOBE_W / 2;
  const cy = GLOBE_H / 2;
  const cosR = Math.cos(rotation);
  const sinR = Math.sin(rotation);

  const lines = [];

  for (let row = 0; row < GLOBE_H; row++) {
    let line = '';
    for (let col = 0; col < GLOBE_W; col++) {
      const sx = (col - cx) * CHAR_ASPECT;
      const sy = (row - cy);
      const z2 = radius * radius - sx * sx - sy * sy;

      if (z2 < 0) {
        line += ' ';
        continue;
      }

      const sz = Math.sqrt(z2);
      const invR = 1 / radius;
      const nx = sx * invR;
      const ny = sy * invR;
      const nz = sz * invR;

      const intensity = Math.max(0, nx*LIGHT[0] + ny*LIGHT[1] + nz*LIGHT[2]);

      const xRot = sx * cosR - sz * sinR;
      const zRot = sx * sinR + sz * cosR;

      const lat = Math.asin(Math.max(-1, Math.min(1, -sy / radius))) * DEG;
      const lon = Math.atan2(xRot, zRot) * DEG;

      const onLand = isLandCached(lat, lon);

      let si;
      if (onLand) {
        si = landBase + Math.floor(intensity * landRange);
        si = Math.max(landBase, Math.min(maxSI, si));
      } else {
        si = 1 + Math.floor(intensity * oceanRange);
        si = Math.max(1, Math.min(landBase - 1, si));
      }

      const edge = sz / radius;
      if (edge < 0.2) {
        si = Math.max(0, si - 3);
      } else if (edge < 0.35) {
        si = Math.max(0, si - 1);
      }

      line += SHADE[si];
    }
    lines.push(line);
  }

  return lines.join('\n');
}

// ── Status message cycling ─────────────────────────────────────────
const MESSAGES = [
  'Fetching scrobbles',
  'Resolving Spotify tracks',
  'Building audio profile',
  'Analyzing audio features',
  'Computing genre vectors',
  'Matching cities',
  'Ranking destinations',
];

let currentMsg = 0;
const statusEl = document.getElementById('status');

function cycleStatus() {
  statusEl.classList.add('fading');
  setTimeout(() => {
    currentMsg = (currentMsg + 1) % MESSAGES.length;
    statusEl.textContent = MESSAGES[currentMsg];
    statusEl.classList.remove('fading');
  }, 400);
}

setInterval(cycleStatus, 3200);

// ── Drag interaction ──────────────────────────────────────────────
const globeEl = document.getElementById('globe');
const containerEl = document.getElementById('container');

let isDragging = false;
let dragStartX = 0;
let rotationAtDragStart = 0;
let dragVelocity = 0;         // radians/sec — release velocity

// Rolling velocity buffer: stores recent (timestamp, x) samples
const velocitySamples = [];
const VELOCITY_WINDOW = 80;   // ms — only use the last 80ms of drag for velocity

const DRAG_SENSITIVITY = 0.008;   // radians per pixel of drag
const FLICK_FRICTION = 1.2;       // exponential decay rate (lower = longer coast)

function onPointerDown(e) {
  isDragging = true;
  dragStartX = e.clientX;
  rotationAtDragStart = rotation;
  dragVelocity = 0;
  velocitySamples.length = 0;
  velocitySamples.push({ t: performance.now(), x: e.clientX });
  globeEl.classList.add('dragging');
  e.preventDefault();
}

function onPointerMove(e) {
  if (!isDragging) return;
  const now = performance.now();

  // Record sample for velocity estimation
  velocitySamples.push({ t: now, x: e.clientX });
  // Trim samples older than the window
  while (velocitySamples.length > 1 && now - velocitySamples[0].t > VELOCITY_WINDOW) {
    velocitySamples.shift();
  }

  // Update rotation directly from total drag distance
  const totalDx = e.clientX - dragStartX;
  rotation = rotationAtDragStart + totalDx * DRAG_SENSITIVITY;
  e.preventDefault();
}

function onPointerUp(e) {
  if (!isDragging) return;
  isDragging = false;
  globeEl.classList.remove('dragging');

  // Compute release velocity from the rolling window of samples
  if (velocitySamples.length >= 2) {
    const first = velocitySamples[0];
    const last = velocitySamples[velocitySamples.length - 1];
    const dt = (last.t - first.t) / 1000;
    if (dt > 0.005) {  // need at least 5ms of data
      const dx = last.x - first.x;
      dragVelocity = (dx * DRAG_SENSITIVITY) / dt;
      // Clamp to a reasonable max spin speed
      dragVelocity = Math.max(-6, Math.min(6, dragVelocity));
    }
  }
  velocitySamples.length = 0;
  e.preventDefault();
}

// Pointer events (works for mouse + touch)
globeEl.addEventListener('pointerdown', onPointerDown);
window.addEventListener('pointermove', onPointerMove);
window.addEventListener('pointerup', onPointerUp);
globeEl.addEventListener('selectstart', (e) => e.preventDefault());

// ── Animation loop ─────────────────────────────────────────────────
let rotation = 0;
let lastTime = 0;
const TARGET_SPEED = 0.3;     // cruise speed in radians/sec
const SPIN_UP_RATE = 0.08;    // how fast auto-spin accelerates (rad/s per second)
let autoSpeed = 0;            // current auto-rotation speed (starts at 0)
let startTime = 0;

function animate(time) {
  if (!startTime) startTime = time;
  const dt = lastTime ? (time - lastTime) / 1000 : 0;
  lastTime = time;

  if (!isDragging) {
    // Apply flick velocity with exponential decay
    if (Math.abs(dragVelocity) > 0.002) {
      rotation += dragVelocity * dt;
      dragVelocity *= Math.exp(-FLICK_FRICTION * dt);
    } else {
      dragVelocity = 0;
    }

    // Auto-spin resumes once flick velocity is negligible
    if (Math.abs(dragVelocity) < TARGET_SPEED * 0.5) {
      autoSpeed = Math.min(TARGET_SPEED, autoSpeed + SPIN_UP_RATE * dt);
      rotation += autoSpeed * dt;
    } else {
      autoSpeed = 0;
    }
  }

  // Keep rotation in [0, 2π)
  rotation = ((rotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);

  globeEl.textContent = renderGlobe(rotation);
  requestAnimationFrame(animate);
}

// ── Fade-in on load ───────────────────────────────────────────────
loadWorldMap().then(() => {
  containerEl.style.transition = 'opacity 2.5s ease-out, transform 3s ease-out';
  containerEl.style.opacity = '1';
  containerEl.style.transform = 'scale(1)';
  requestAnimationFrame(animate);
});
</script>

</body>
</html>
